# 计算机图形学——软光栅渲染器

<center>同济大学软件学院</center>
<center>指导老师：贾金原老师</center>
<center>1754060 张喆<br/>1753188 陈开昕<br/>1652699 林磊</center>
[TOC]

------

## 一. 概述：渲染流水线

**流水线功能**：给定一个虚拟相机、一些三维物体、灯光、着色方程、贴图等资源，最终生成一张二维图片

- **Application（应用程序阶段）**：游戏逻辑、物理等

- **Geometry（几何阶段）**：处理上一个阶段传递来的图元和位置等信息，计算变换位置，最终决定物体在屏幕上的哪个位置。主要是顶点着色器（MVP变换）、裁剪、屏幕映射、裁剪等

  ![image-20200112145239657](计算机图形学——软光栅渲染器.assets/image-20200112145239657.png)

- **Rasterizer（光栅化阶段）**：将上一阶段变换投影后屏幕空间的顶点（包括顶点包含的各种数据），转化为屏幕上像素的过程。主要是三角形数据的设置、数据差值、像素着色、ALpha测试、深度测试、模板测试、混合等

  ![image-20200112145409483](计算机图形学——软光栅渲染器.assets/image-20200112145409483.png)

------

## 二. 顶点变换及画线

### 顶点变换过程

![image-20200112110909019](计算机图形学——软光栅渲染器.assets/image-20200112110909019.png)

### 数据结构

#### 矩阵、向量

- **矩阵**

  ```c++
  /* 矩阵 */
  typedef struct
  { 
    float m[4][4]; 
  } matrix_t;  
  ```

- **矩阵运算**

  ```c++
  //c=a+b
  void matrix_add(matrix_t *c,const matrix_t *a,const matrix_t *b);
  //c=a-b
  void matrix_sub(matrix_t *c,const matrix_t *a,const matrix_t *b);
  //c=a*b
  void matrix_mul(matrix_t *c,const matrix_t *a,const matrix_t *b);
  //c=a*i
  void matrix_scale(matrix_t *c,const matrix_t *a,float i);
  //y=x*m;向量和矩阵相乘
  void matrix_apply(vector_t *y,const vector_t *x,const matrix_t *m); 
  //重置为单位矩阵
  void matrix_set_identity(matrix_t *m); 
  //重置为零矩阵 
  void matrix_set_zero(matrix_t *m);
  //平移变换的平移矩阵 
  void matrix_set_translate(matrix_t *m,float x,float y,float z); 
  //缩放变换的缩放矩阵
  void matrix_set_scale(matrix_t *m,float x,float y,float z); 
  //旋转变换的旋转矩阵
  void matrix_set_rotate(matrix_t *m,float x,float y,float z,float theta); 
  //摄像头设置
  void matrix_set_lookat(matrix_t *m,const vector_t *eye,const vector_t *at,const vector_t *up);
  //透视投影矩阵设置
  void matrix_set_perspective(matrix_t *m,float fovy,float aspect,float zn,float zf);
  ```

- **向量**

  ```c++
  /*向量*/
  typedef struct
  {
    float x;
    float y;
    float z;
    float w;
  } vector_t;
  ```

- **向量运算**

  ```c++
  //如果x超出了边界，就选边界；如果x没有超出边界，就选x；在判断颜色值的时候用到
  int CMID(int x,int min,int max);
  //z=x+y
  void vector_add(vector_t *z,const vector_t *x,const vector_t *y);
  //z=x-y
  void vector_sub(vector_t *z,const vector_t *x,const vector_t *y);
  //数量积
  float vector_dotproduct(const vector_t *x,const vector_t *y);
  //向量积 
  void vector_crossproduct(vector_t *z,const vector_t *x,const vector_t *y);
  //计算插值：t∈[0,1] 
  float interp(float x1,float y1,float t);
  //矢量插值：t∈[0,1]
  void vector_interp(vector_t *z,const vector_t *x,const vector_t *y,float t); 
  //矢量归一化 
  void vector_normalize(vector_t *v); 
  ```



#### 坐标变换

```c++
/* 坐标变换 */
typedef struct
{
  matrix_t world;				//世界坐标系变换 
  matrix_t view;				//照相机坐标变换 
  matrix_t projection;	//投影变换 
  matrix_t transform;		//transfrom=world*view*projection 
  float w;							//宽 
  float h;							//高 
} transform_t;
```

- **坐标变换相关方法**

  ```c++
   //矩阵更新，计算：transfrom=world*view*projection 
   void transform_update(transform_t *ts);
   //初始化，设置屏幕宽高和变换矩阵 
   void transform_init(transform_t *ts, int width, int height); 
   //将点坐标进行坐标变换
   void transform_apply(const transform_t *ts, vector_t *y, const vector_t *x); 
   //检查齐次坐标同CVV的边界用于视锥体的裁剪
   int transform_check_cvv(const vector_t *v); 
   //归一化，得到屏幕坐标 
   void transform_homogenize(const transform_t *ts, vector_t *y, const vector_t *x);
  ```



#### 几何计算

- **RGB颜色**

  ```c++
  /* RGB颜色 */
  typedef struct
  {
    float r;
    float g;
    float b;
  } color_t;
  ```

- **纹理坐标**

  ```c++
  /* 纹理坐标 */
  typedef struct
  {
    float u;
    float v;
  } texcoord_t;
  ```

- **顶点**

  ```c++
  /* 顶点 */
  typedef struct
  {
    point_t pos;
    texcoord_t tc;
    color_t color;
    float rhw;			//rhw=1/w，用来做深度测试用的；经过projection乘法后，w与z是线性关系，所以用z做深度测试，可以用w缓存来代替，因为除法代价太大，所以事先保存成1/w  
  } vertex_t;
  ```

- **边**

  ```c++
  /* 边 */
  typedef struct
  {
    vertex_t v;			//保存Y=y与left、right的交点 
    vertex_t v1;
    vertex_t v2;
  } edge_t;
  ```

- **梯形**

  ```c++
  /* 梯形 */
  typedef struct
  {
    float top;			//方便水平扫描线识别扫描的垂直范围 
    float bottom;
    edge_t left;		//左边的边 
    edge_t right;		//右边的边 
  } trapezoid_t;
  ```

- **扫描线**

  ```c++
  /* 扫描线 */
  typedef struct
  {
    vertex_t v;			//v中存放的是扫描线的浮点型，也即原来left与Y=y的交点，存放当前扫描线的点 
    vertex_t step;	//步长 
    int x;					//x,y中存放的是扫描线起点的整型，因为像素是整型的 
    int y;
    int w;					//扫描线的宽 
  } scanline_t;
  ```

- **几何变化相关方法**

  ```c++
   //除pos坐标外，全部除rhw，颜色、纹理渐变，若点不是在同一深度，就需要把z方向上的渐变也考虑进去，所以要同除w
   void vertex_rhw_init(vertex_t *v); 
   //顶点插值
   void vertex_interp(vertex_t *y,const vertex_t *x1,const vertex_t *x2,float t);
   //步长计算有用到 
   void vertex_division(vertex_t *y,const vertex_t *x1,const vertex_t *x2,float w);
   //顶点加法 
   void vertex_add(vertex_t *y,const vertex_t *x); 
   //按照Y坐标计算出左右两边纵坐标等于 y 的顶点 
   void trapezoid_edge_interp(trapezoid_t *trap,float y); 
   //根据左右两边的端点，初始化计算扫描线的起点和步长
   void trapezoid_init_scan_line(const trapezoid_t *trap,scanline_t *scanline,int y); 
   //根据三角形生成0~2个梯形，并且返回合法梯形的数量（我的注释：将三角形分割成可以扫描的水平三角形）
   int trapezoid_init_triangle(trapezoid_t *trap,const vertex_t *p1,const vertex_t *p2,const vertex_t *p3);
  ```
  
  

### 坐标变换

#### 基础知识

![坐标变换](计算机图形学——软光栅渲染器.assets/坐标变换.png)

3D物体从三维空间映射到二维屏幕，需要经历一系列坐标系变换：

1. **model**：局部坐标系（物体原本的坐标系），是相对的坐标系，主要进行模型空间的绘制
2. **world**：世界坐标系，物体放在世界里的坐标。系统的绝对坐标系，在没有建立用户坐标系之前所有点的坐标都是以该坐标系的原点来确定的
3. **camera**：相机坐标系，相机也是世界里的一个物体，相机坐标就是以相机位置为坐标原点，相机的朝向为Z轴方向的坐标系。因为我们在电脑里看到的物体其实都是“相机”帮助我们看的，“相机”就是我们的眼睛，所以要以相机为标准进行坐标转换
4. **perspective**：透视坐标系，三维坐标向二维平面进行映射。(x, y)的范围 在[-1, 1]，z 的范围在[0, 1]
5. **screen**：屏幕坐标系，原点在屏幕的左上角，x 轴朝右，y 轴朝下。x 的范 围在[0, xres-1]，y 的范围在[0, yres-1]

**注意**

- 物体的位移、缩放、旋转会改变它的world坐标，不会改变model坐标
- 在model、world、camera坐标下，X、Y、Z的范围都是无穷大，但是坐标系的基准不一样
- 在实际的渲染引擎运行中，Xsp和Xpc基本不会改变，因为屏幕分辨率很少会改变
- Xcw会在相机移动和旋转时改变
- Xwm会在物体平邑、旋转和旋转时改变

#### model到world的转换

从模型本身的相对坐标变换到世界坐标，主要是平移、旋转和缩放

本项目中
$$
world = \begin{bmatrix}1 & 0 & 0 & 0 \\ 0& 1 & 0 & 0 \\0 & 0 & 1 & 0 \\0 & 0 & 0 & 1\\\end {bmatrix}
$$

- **平移**

  - 每次按下键盘方向上下键改变pos

    ```c++
    camera_at_zero(&device, pos, 0, 0)
    ```

  - 改变camera中eye位置，即改变坐标变换中view矩阵

- **旋转**

  - 每次按下键盘方向左右键改变alpha

    ```c++
    matrix_set_rotate(&m, -1, -0.5, 1, alpha)
    ```

  - 例. 旋转改变world坐标系，在该项目中，设绕(-1, 0.5, 1)旋转，先旋转两次使旋转轴与坐标轴重合，再绕坐标轴旋转alpha角度，再呈上旋转你矩阵，将旋转轴转动回来

    按下图方式进行world矩阵的求解

    ![image-20200112154946332](计算机图形学——软光栅渲染器.assets/image-20200112154946332.png)

#### world到camera的转换

1. 设相机的中心点在世界中的位置时$C(C_x,C_y, C_z)$，相机正在看的点点位置是$I(I_x, I_y,I_z)$
2. 则，相机的Z轴就是它看的方向向量，即$CI$向量，即$I-C = (I_x-C_x, I_y-C_y, I_z-C_z)$，将其归一化得到Z轴单位向量
3. 取世界坐标系中的$up$向量$(0,1,0)$, $up^{'} = up-(up·Z)Z$
4. 将$up^{'}$归一化得到Y，$Y\times Z = X$
5. 将$up \times Z$，得到向量$X_1$，将$X_1$归一化，得到X轴的单位向量
6. 再通过Z轴的单位向量与X轴的单位向量叉乘，即$Z \times X$，就得到了Y轴的单位向量

![image-20200112160857457](计算机图形学——软光栅渲染器.assets/image-20200112160857457.png)

**构造坐标系转换的变换矩阵**：

1. 世界坐标系中，相机原点为$(C_x,c_y,C_z)$，在相机坐标系中为$(0,0,0)$，因此$(0,0,0)=Xuw*(C_x,C_y,C_z)$

2. 世界坐标系中，相机的三个轴为$X+C(X_x+C_x,X_y+C_y,X_z+C_z), Y+C(Y_x+C_x,Y_y+C_y,Y_z+C_z), Z+C(Z_x+C_x,Z_y+C_y,Z_z+C_z)$，但在相机坐标系下为$(1,0,0),(0,1,0),(0,0,1)$

   因此
   $$
   (1,0,0)= X+C(X_x+C_x,X_y+C_y,X_z+C_z)\\
   (0,1,0)=  Y+C(Y_x+C_x,Y_y+C_y,Y_z+C_z)\\
   (0,0,1)= Z+C(Z_x+C_x,Z_y+C_y,Z_z+C_z)
   $$

3. 综上可求出$X_{iw}$，表示先把坐标系移动到相机的原点处，然后再旋转来调整到相机的X，Y，Z轴
   $$
   X_{iw} = \begin{pmatrix} X_x & X_y & X_z & -X·C \\ Y_x & Y_y & Y_z & -Y·C \\Z_x & Z_y & Z_z & -Z·C \\ 0 & 0 & 0 & 1\end{pmatrix}
   $$
   

#### camera到perspective的转换

- **视锥体**：视椎体是能看到的区域，从眼睛或者摄像机的焦距一直到能看到的最远距离其中的空间。由于越远的东西看上去越小，可以看到的范围也就越大。这样，从焦距到可以看到的最远距离的可见区域增大，使得整个可见区域变成一个椎体，这就是视椎体

  原点到焦距的距离称为近平面距离，用字母 n 表示;原点到最远可见距离 称为远平面距离，用字母 f 表示。这两个平面的距离就是视椎体的“高(z 轴)” 用字母 d 表示。视角代表一个椎体的顶点角度，这个角度越宽视野就越开阔。但是电脑屏幕是矩形的，这个椎体不是圆锥，而是一个四棱锥，因此存在垂直视角和水平视角的问题。

- 投射矩阵的左右就是把一个视锥体变换到一个规范化设备坐标上

- 规范化设备坐标是一个立方体，在 WebGL 中，它的坐标是从(-1,-1,-1)到 (1,1,1)。在这个区域中的东西就被正交投影到屏幕上。因此需要构造一个投射矩 阵把视椎体的东西变换到规范化设备坐标上。因此只要把视椎体变成立方体就可以了。由于上面规定了它是个正四棱锥，所以x方向和y方向的处理是完全一样 的

- 把视锥的x和y坐标都变换到规范设备区域坐标的范围内，这样就可以得到一个细长的长方体

![image-20200112192529941](计算机图形学——软光栅渲染器.assets/image-20200112192529941.png)

#### perspective到screen的转换

- **归一化设备坐标**：透视除法，将所有项都除以w，将最后一项变为1
- **将归一化的设备坐标转化为屏幕坐标**：定义屏幕分辨率为$xs × rs$，要将透视坐标系里的点映射过来。屏幕坐标系的原点是左上角，而 perspective 里的原点(0，0)在屏幕中应该位于屏幕中央， 即$(\frac{xs}{2}, \frac{ys}{2})$。那么 perspective 里的原点(0，0)会映射为$(\frac{xs}{2}, \frac{ys}{2})$， 即位移一个(xs/2, ys/2，0)。屏幕坐标系中 x 的范围是[0, xs)，y 的范围是[0, ys)。而 perspective 坐标系中 x 和 y 的范围是[-1,1]，所以这个映射还要满足-1 映射到0，1映射到xs或ys。

![image-20200112193342603](计算机图形学——软光栅渲染器.assets/image-20200112193342603.png)

- 之后，将顶点坐标乘以transform吼再转换为屏幕坐标
  $$
  Transform = world * view * projection
  $$
  

### 以线框形式绘制立方体



------

## 三. 光栅化

### 渲染过程

![image-20200112110917568](计算机图形学——软光栅渲染器.assets/image-20200112110917568.png)



### 数据结构

#### 渲染设备

```c++
/* 渲染设备 */
typedef struct
{
  transform_t transform;			//坐标变换器 
  int width;									//窗口宽度 
  int height;									//窗口高度  
  IUINT32 **framebuffer;			//像素缓存：framebuffer[y]代表第y行，存储的是颜色(32位)
  float **zbuffer;						//深度缓存
  IUINT32 **texture;					//纹理 
  int tex_width;							//纹理宽度 
  int tex_height;							//纹理高度 
  float max_u;								//纹理最大宽度：tex_width - 1 
  float max_v;								//纹理最大高度：纹理坐标：v*max_v，其中v∈[0,1] 
  int render_state;						//渲染状态 
  IUINT32 background;					//背景颜色 
  IUINT32 foreground;					//线框颜色 
  light_t light;							//光照
} device_t;
```

- **渲染设备相关方法**

  ```c++
  //设备初始化，fb为外部帧缓存，非NULL将引用外部缓存帧缓存（每行对齐4字节） 
  void device_init(device_t *device,int width,int height,void *fb);
  //删除设备
  void device_destroy(device_t *device);
  //设置当前纹理 
  void device_set_texture(device_t *device,void *bits,long pitch,int w,int h); 
  //清空framebuffer和zbuffer
  void device_clear(device_t *device,int mode);
  //画点 
  void device_pixel(device_t *device,int x,int y,IUINT32 color);
  //画线段 
  void device_draw_line(device_t *device,int x1,int y1,int x2,int y2,IUINT32 c);
  //根据坐标读取纹理 
  IUINT32 device_texture_read(const device_t *device,float u,float v);
  ```

  

#### 状态变量

```c++
const int RENDER_STATE_WIREFRAME=1;										//渲染线框
const int RENDER_STATE_TEXTURE=2;											//渲染纹理 
const int RENDER_STATE_COLOR=4; 											//渲染颜色
const int RENDER_STATE_LIGHT_GLOBAL_AMBIENT=8;				//全局环境光
const int RENDER_STATE_LIGHT_DIFFUSE_REFLECTION=16;		//漫反射光
```

------

## 四. 纹理



------

## 五. 光照

#### 光照

```c++
/* 光照 */
typedef struct  
{
  color_t light;//光照颜色
  point_t pos;//光照位置
} light_t;
```

- **光照相关方法**

  ```c++
   //全局环境光
   void global_ambient_light(device_t *device,light_t *light);
   //设置光照颜色
   void set_light_color(light_t *light,float r,float g,float b);
   //设置光照位置
   void set_light_pos(light_t *light,int x,int y,int z);
   //光照
   void open_light(device_t *device,light_t *light);
   //加载图片
   void loadbmp(const char *szfilename,IUINT32 t[256][256]);
  ```

------

## 六. 实验结果



------

## 七. 代码实现



------

## 八. 参考资料

1. 深入探索透视纹理映射

   https://blog.csdn.net/u012419410/article/details/41989501

2. mini3D

   http://www.skywind.me/blog/archives/1498

3. 视图矩阵(View Matrix)的推导

   https://www.web-tinker.com/article/20177.html

4. 投射矩阵(Projection Martrix)的推导

   https://www.web-tinker.com/article/20157.html

5. OpenGL 学习脚印:OpenGL 坐标变换

   http://www.360doc.com/content/14/1028/10/19175681_420522107.shtml
   
6. 从迷你光栅化软渲染器的实现看渲染流水线

   https://blog.csdn.net/puppet_master/article/details/80317178